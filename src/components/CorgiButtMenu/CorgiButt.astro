---
---
<div id="pixi-corgi-wrapper">
    <div id="pixi-corgi-container"></div>
    <div id="drag-overlay"></div>
</div>

<style>
    #pixi-corgi-wrapper {
        position: relative;
        width: 500px;
        height: 500px;
        margin: 0 auto;
    }
    #pixi-corgi-container {
        width: 100%;
        height: 100%;
    }
    #drag-overlay {
        position: absolute;
        /* 大きくなったキャンバスに合わせて調整 */
        top: 210px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px; 
        height: 260px;
        background-color: transparent;
        cursor: grab;
        touch-action: none;
        z-index: 100;
        border-radius: 50%;
    }
    #drag-overlay:active {
        cursor: grabbing;
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }
</style>

<script>
    import * as PIXI from 'pixi.js';
    import corgiImg from '../../assets/corgi.png';
    import corgiButtImg from '../../assets/corgi-butt.png';

    async function init() {
        const container = document.getElementById('pixi-corgi-container');
        const overlay = document.getElementById('drag-overlay');
        
        if (!container || !overlay) return;

        const app = new PIXI.Application();
        await app.init({
            width: 500,
            height: 500,
            backgroundAlpha: 0,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });

        container.appendChild(app.canvas);

        const getSrc = (img: any) => typeof img === 'string' ? img : img.src;
        const [texBody, texButt] = await Promise.all([
            PIXI.Assets.load(getSrc(corgiImg)),
            PIXI.Assets.load(getSrc(corgiButtImg))
        ]);

        const centerX = 250;
        const centerY = 250;
        const buttInitialY = centerY + 30; // ユーザー調整済みの初期位置
        const scale = 1.0; 

        // 画像の余白が多いため、anchorとpivotを中心(0.5)に設定して重ねます
        
        // 体
        const body = new PIXI.Sprite(texBody);
        body.anchor.set(0.5);
        body.x = centerX;
        body.y = centerY; // 体はそのまま
        body.scale.set(scale);
        app.stage.addChild(body);

        // お尻
        const verticesX = 20;
        const verticesY = 20;
        const mesh = new PIXI.Mesh({
            geometry: new PIXI.PlaneGeometry({
                width: texButt.width,
                height: texButt.height,
                verticesX,
                verticesY
            }),
            texture: texButt,
        });
        
        // メッシュも中心を基準にして配置。
        mesh.pivot.set(texButt.width / 2, texButt.height / 2);
        mesh.x = centerX;
        mesh.y = buttInitialY; 
        mesh.scale.set(scale);
        app.stage.addChild(mesh);

        const posAttr = mesh.geometry.getAttribute('aPosition');
        const originalPositions = new Float32Array(posAttr.buffer.data);

        let dragging = false;
        let startPos = { x: 0, y: 0 };

        overlay.addEventListener('pointerdown', (e) => {
            dragging = true;
            startPos = { x: e.clientX, y: e.clientY };
            overlay.setPointerCapture(e.pointerId);
        });

        overlay.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            let dx = e.clientX - startPos.x;
            let dy = e.clientY - startPos.y;
            const dragDist = Math.sqrt(dx * dx + dy * dy);
            
            if (dragDist < 2) return;

            // 引っ張れる上限を設定 (150px)
            const MAX_DRAG_DIST = 120;
            if (dragDist > MAX_DRAG_DIST) {
                const ratio = MAX_DRAG_DIST / dragDist;
                dx *= ratio;
                dy *= ratio;
            }

            const data = posAttr.buffer.data as Float32Array;
            const w = texButt.width;
            const h = texButt.height;
            
            // ドラッグの向き（正規化ベクトル）
            const ux = dx / dragDist;
            const uy = dy / dragDist;

            // ポイント：ドラッグしている方向にある「外縁のターゲット地点」
            // PlaneGeometryの頂点座標系 (0 〜 w, 0 〜 h) に合わせる
            const edgeTargetX = (w / 2) + (w / 2) * ux;
            const edgeTargetY = (h / 2) + (h / 2) * uy;

            for (let i = 0; i < data.length; i += 2) {
                const ox = originalPositions[i];
                const oy = originalPositions[i + 1];
                
                // ターゲット地点（外端）からの距離を正しく計算
                const distToEdge = Math.sqrt(Math.pow(ox - edgeTargetX, 2) + Math.pow(oy - edgeTargetY, 2));
                
                // 少し柔らかい減衰 (画像の25%程度に影響を広げる)
                const sigma = w * 0.25;
                const weight = Math.exp(-(distToEdge * distToEdge) / (2 * sigma * sigma));
                
                // 指数を下げてシャープさを落とす (3 -> 1.5)
                const softWeight = Math.pow(weight, 1.5);
                
                // 伸びを抑えるために 0.6倍 の係数を追加
                data[i] = ox + (dx / scale) * softWeight * 0.6;
                data[i + 1] = oy + (dy / scale) * softWeight * 0.6;
            }
            posAttr.buffer.update();

            window.dispatchEvent(new CustomEvent('corgi-drag', {
                detail: { x: e.clientX, y: e.clientY, dx, dy }
            }));
        });

        const onUp = () => {
            if (!dragging) return;
            dragging = false;

            // バネアニメーション用の速度情報
            let vx = 0;
            let vy = 0;
            const vertexVelocities = new Float32Array(posAttr.buffer.data.length);
            
            const snap = () => {
                if (dragging) return;
                const data = posAttr.buffer.data as Float32Array;
                let finished = true;
                
                // --- 全体の位置のバネ挙動 (画像全体が極めてゆったり揺れる) ---
                const ax = (centerX - mesh.x) * 0.04; // 復元力をさらに半分に (0.08 -> 0.04)
                const ay = (buttInitialY - mesh.y) * 0.04;
                vx = (vx + ax) * 0.96; // 勢いをさらに維持 (0.94 -> 0.96)
                vy = (vy + ay) * 0.96;
                mesh.x += vx;
                mesh.y += vy;

                // --- 頂点ごとのバネ挙動 (皮がスローにプルプル揺れる) ---
                for (let i = 0; i < data.length; i++) {
                    const diff = originalPositions[i] - data[i];
                    const accel = diff * 0.01;
                    vertexVelocities[i] = (vertexVelocities[i] + accel) * 0.96;
                    data[i] += vertexVelocities[i];
                    
                    // 揺れが極めて小さくなるまで続ける
                    if (Math.abs(vertexVelocities[i]) > 0.001 || Math.abs(diff) > 0.01) {
                        finished = false;
                    }
                }

                if (Math.abs(vx) > 0.01 || Math.abs(vy) > 0.01) finished = false;

                posAttr.buffer.update();
                if (!finished) {
                    requestAnimationFrame(snap);
                } else {
                    // 最終的に位置を完全リセット
                    mesh.x = centerX;
                    mesh.y = buttInitialY;
                    for (let i = 0; i < data.length; i++) data[i] = originalPositions[i];
                    posAttr.buffer.update();
                }
            };
            requestAnimationFrame(snap);
            window.dispatchEvent(new CustomEvent('corgi-drop'));
        };

        overlay.addEventListener('pointerup', onUp);
        overlay.addEventListener('pointercancel', onUp);
    }

    if (document.readyState === 'complete') {
        init();
    } else {
        window.addEventListener('load', init);
    }
</script>
